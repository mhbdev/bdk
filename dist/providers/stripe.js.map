{"version":3,"sources":["../../src/providers/stripe.ts"],"names":["options"],"mappings":"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","file":"stripe.js","sourcesContent":["import type {\n  PaymentProvider,\n  WebhookOptions,\n  WebhookResult,\n  CheckoutOptions,\n  CheckoutSession,\n  SubscriptionOptions,\n  Subscription,\n  GetSubscriptionOptions,\n  CancelSubscriptionOptions,\n  Customer,\n  Product,\n  Price,\n  PaymentMethod,\n  PaymentResult\n} from '../types';\nimport type {\n  UsageRecordOptions,\n  UsageRecordResult\n} from '../types';\n/**\n * Stripe Provider for Payment Gateway\n * \n * Implements the Stripe payment provider interface.\n */\n\n/**\n * Create a Stripe provider\n * @param {Object} options - Configuration options\n * @param {string} options.secretKey - Stripe secret key\n * @param {string} options.publishableKey - Stripe publishable key\n * @param {string} options.webhookSecret - Stripe webhook secret\n * @param {Object} options.products - Product configuration\n * @param {Object} options.prices - Price configuration\n * @param {boolean} options.debug - Enable debug mode\n * @returns {Object} - Stripe provider\n */\ninterface StripeProviderOptions {\n  secretKey: string | null;\n  publishableKey: string | null;\n  webhookSecret: string | null;\n  products: Record<string, unknown>;\n  prices: Record<string, unknown>;\n  debug: boolean;\n}\n\nexport function createStripeProvider(options: Partial<StripeProviderOptions> = {}): PaymentProvider {\n  // Default options\n  const config: StripeProviderOptions = {\n    secretKey: null,\n    publishableKey: null,\n    webhookSecret: null,\n    products: {},\n    prices: {},\n    debug: false,\n    ...options\n  };\n  \n  // Validate required options\n  if (!config.secretKey) {\n    throw new Error('Stripe secret key is required');\n  }\n  \n  // Initialize Stripe\n  let stripe: any;\n  try {\n    // Dynamically import Stripe to avoid requiring it for all providers\n    const Stripe = require('stripe');\n    stripe = new Stripe(config.secretKey, {\n      apiVersion: '2023-10-16'\n    });\n    \n    _log('Stripe initialized successfully');\n  } catch (error: unknown) {\n    _log('Error initializing Stripe:', error);\n    const err = error instanceof Error ? error : new Error(String(error));\n    throw new Error(`Failed to initialize Stripe: ${err.message}`);\n  }\n  \n  /**\n   * Create a checkout session\n   * @param {Object} options - Checkout options\n   * @param {string} options.customerId - Customer ID (optional)\n   * @param {string} options.customerEmail - Customer email (optional)\n   * @param {string} options.priceId - Price ID\n   * @param {string} options.successUrl - Success URL\n   * @param {string} options.cancelUrl - Cancel URL\n   * @param {Object} options.metadata - Additional metadata\n   * @param {string} options.mode - Checkout mode (payment, subscription, setup)\n   * @param {string} options.currency - Currency code (default: USD)\n   * @param {number} options.amount - Amount in smallest currency unit (e.g., cents)\n   * @returns {Promise<Object>} - Checkout session\n   */\n  async function createCheckoutSession(options: CheckoutOptions): Promise<CheckoutSession> {\n    try {\n      _log('Creating Stripe checkout session:', options);\n      \n      // Prepare line items\n      const lineItems: Array<{ price?: string; quantity: number; price_data?: { currency: string; product_data: { name: string; description?: string } ; unit_amount: number } }> = [];\n      \n      if (options.priceId) {\n        // Use price ID directly\n        lineItems.push({\n          price: options.priceId,\n          quantity: 1\n        });\n      } else if (options.amount && options.currency) {\n        // Create a one-time price\n        const productName = typeof options.productName === 'string' ? options.productName : 'Payment';\n        const productDescription = typeof options.description === 'string' ? options.description : undefined;\n        lineItems.push({\n          price_data: {\n            currency: options.currency.toLowerCase(),\n            product_data: {\n              name: productName,\n              description: productDescription\n            },\n            unit_amount: options.amount\n          },\n          quantity: 1\n        });\n      } else {\n        throw new Error('Either priceId or amount and currency must be provided');\n      }\n      \n      // Prepare session parameters\n      const sessionParams: Record<string, unknown> = {\n        line_items: lineItems,\n        mode: options.mode || 'payment',\n        success_url: options.successUrl,\n        cancel_url: options.cancelUrl,\n        metadata: options.metadata || {}\n      };\n      \n      // Add customer if provided\n      if (options.customerId) {\n        sessionParams.customer = options.customerId;\n      } else if (options.customerEmail) {\n        sessionParams.customer_email = options.customerEmail;\n      }\n      \n      // Create the session\n      const session = await stripe.checkout.sessions.create(sessionParams);\n      \n      _log('Stripe checkout session created:', session.id);\n      \n      // Return a standardized response\n      return {\n        id: session.id,\n        url: session.url,\n        status: session.status,\n        customerId: session.customer,\n        customerEmail: session.customer_email,\n        mode: session.mode,\n        paymentStatus: session.payment_status,\n        amountTotal: session.amount_total,\n        currency: session.currency,\n        metadata: session.metadata,\n        expiresAt: session.expires_at ? new Date(session.expires_at * 1000).toISOString() : null,\n        provider: 'stripe',\n        providerData: {\n          sessionId: session.id,\n          paymentIntentId: session.payment_intent,\n          subscriptionId: session.subscription\n        }\n      };\n    } catch (error) {\n      _log('Error creating Stripe checkout session:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Create a subscription\n   * @param {Object} options - Subscription options\n   * @param {string} options.customerId - Customer ID\n   * @param {string} options.priceId - Price ID\n   * @param {Object} options.metadata - Additional metadata\n   * @param {string} options.paymentMethodId - Payment method ID (optional)\n   * @returns {Promise<Object>} - Subscription\n   */\n  async function createSubscription(options: SubscriptionOptions): Promise<Subscription> {\n    try {\n      _log('Creating Stripe subscription:', options);\n      \n      // Validate required options\n      if (!options.customerId) {\n        throw new Error('Customer ID is required');\n      }\n      \n      if (!options.priceId) {\n        throw new Error('Price ID is required');\n      }\n      \n      // Prepare subscription parameters\n      const subscriptionParams: Record<string, unknown> = {\n        customer: options.customerId,\n        items: [{ price: options.priceId }],\n        metadata: options.metadata || {}\n      };\n      \n      // Add payment method if provided\n      if (options.paymentMethodId) {\n        subscriptionParams.default_payment_method = options.paymentMethodId;\n      }\n      \n      // Create the subscription\n      const subscription = await stripe.subscriptions.create(subscriptionParams);\n      \n      _log('Stripe subscription created:', subscription.id);\n      \n      // Return a standardized response\n      return {\n        id: subscription.id,\n        customerId: subscription.customer,\n        status: subscription.status,\n        currentPeriodStart: new Date(subscription.current_period_start * 1000).toISOString(),\n        currentPeriodEnd: new Date(subscription.current_period_end * 1000).toISOString(),\n        cancelAtPeriodEnd: subscription.cancel_at_period_end,\n        canceledAt: subscription.canceled_at ? new Date(subscription.canceled_at * 1000).toISOString() : null,\n        metadata: subscription.metadata,\n        items: subscription.items.data.map((item: any) => ({\n          id: item.id,\n          priceId: item.price.id,\n          quantity: item.quantity\n        })),\n        provider: 'stripe',\n        providerData: {\n          subscriptionId: subscription.id,\n          latestInvoiceId: subscription.latest_invoice\n        }\n      };\n    } catch (error: unknown) {\n      _log('Error creating Stripe subscription:', error);\n      throw (error instanceof Error ? error : new Error(String(error)));\n    }\n  }\n  \n  /**\n   * Get a subscription\n   * @param {Object} options - Subscription options\n   * @param {string} options.subscriptionId - Subscription ID\n   * @param {string} options.customerId - Customer ID (optional)\n   * @returns {Promise<Object>} - Subscription\n   */\n  async function getSubscription(options: GetSubscriptionOptions): Promise<Subscription | null> {\n    try {\n      _log('Getting Stripe subscription:', options);\n      \n      // Validate required options\n      if (!options.subscriptionId && !options.customerId) {\n        throw new Error('Either subscription ID or customer ID is required');\n      }\n      \n      let subscription;\n      \n      if (options.subscriptionId) {\n        // Get subscription by ID\n        subscription = await stripe.subscriptions.retrieve(options.subscriptionId);\n      } else {\n        // Get subscriptions for customer\n        const subscriptions = await stripe.subscriptions.list({\n          customer: options.customerId,\n          limit: 1,\n          status: 'active'\n        });\n        \n        if (subscriptions.data.length === 0) {\n          return null;\n        }\n        \n        subscription = subscriptions.data[0];\n      }\n      \n      _log('Stripe subscription retrieved:', subscription.id);\n      \n      // Return a standardized response\n      return {\n        id: subscription.id,\n        customerId: subscription.customer,\n        status: subscription.status,\n        currentPeriodStart: new Date(subscription.current_period_start * 1000).toISOString(),\n        currentPeriodEnd: new Date(subscription.current_period_end * 1000).toISOString(),\n        cancelAtPeriodEnd: subscription.cancel_at_period_end,\n        canceledAt: subscription.canceled_at ? new Date(subscription.canceled_at * 1000).toISOString() : null,\n        metadata: subscription.metadata,\n        items: subscription.items.data.map((item: any) => ({\n          id: item.id,\n          priceId: item.price.id,\n          quantity: item.quantity\n        })),\n        provider: 'stripe',\n        providerData: {\n          subscriptionId: subscription.id,\n          latestInvoiceId: subscription.latest_invoice\n        }\n      };\n    } catch (error: unknown) {\n      _log('Error getting Stripe subscription:', error);\n      const err = error as { code?: string };\n      // Return null for not found errors\n      if (err && err.code === 'resource_missing') {\n        return null;\n      }\n      throw (error instanceof Error ? error : new Error(String(error)));\n    }\n  }\n  \n  /**\n   * Cancel a subscription\n   * @param {Object} options - Subscription options\n   * @param {string} options.subscriptionId - Subscription ID\n   * @param {boolean} options.atPeriodEnd - Whether to cancel at the end of the billing period\n   * @returns {Promise<Object>} - Cancellation result\n   */\n  async function cancelSubscription(options: CancelSubscriptionOptions): Promise<unknown> {\n    try {\n      _log('Canceling Stripe subscription:', options);\n      \n      // Validate required options\n      if (!options.subscriptionId) {\n        throw new Error('Subscription ID is required');\n      }\n      \n      let subscription;\n      \n      if (options.atPeriodEnd) {\n        // Cancel at period end\n        subscription = await stripe.subscriptions.update(options.subscriptionId, {\n          cancel_at_period_end: true\n        });\n      } else {\n        // Cancel immediately\n        subscription = await stripe.subscriptions.cancel(options.subscriptionId);\n      }\n      \n      _log('Stripe subscription canceled:', subscription.id);\n      \n      // Return a standardized response\n      return {\n        id: subscription.id,\n        status: subscription.status,\n        cancelAtPeriodEnd: subscription.cancel_at_period_end,\n        canceledAt: subscription.canceled_at ? new Date(subscription.canceled_at * 1000).toISOString() : null,\n        provider: 'stripe',\n        success: true\n      };\n    } catch (error) {\n      _log('Error canceling Stripe subscription:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Handle a webhook event\n   * @param {Object} options - Webhook options\n   * @param {string} options.body - Webhook body\n   * @param {Object} options.headers - Webhook headers\n   * @param {string} options.signature - Webhook signature\n   * @returns {Promise<Object>} - Webhook handling result\n   */\n  async function handleWebhook(options: WebhookOptions): Promise<WebhookResult> {\n    try {\n      _log('Handling Stripe webhook');\n      \n      // Validate required options\n      if (!options.body) {\n        throw new Error('Webhook body is required');\n      }\n      \n      if (!options.signature && !options.headers) {\n        throw new Error('Webhook signature or headers are required');\n      }\n      \n      // Get signature from headers if not provided directly\n      const signature = options.signature || options.headers?.['stripe-signature'];\n      \n      if (!signature) {\n        throw new Error('Stripe signature not found in headers');\n      }\n      \n      // Verify webhook signature\n      let event;\n      \n      try {\n        event = stripe.webhooks.constructEvent(\n          options.body,\n          signature,\n          config.webhookSecret\n        );\n      } catch (error: unknown) {\n        _log('Error verifying webhook signature:', error);\n        const err = error instanceof Error ? error : new Error(String(error));\n        throw new Error(`Webhook signature verification failed: ${err.message}`);\n      }\n      \n      _log('Stripe webhook verified:', event.type);\n      \n      // Process the event\n      let result;\n      \n      switch (event.type) {\n        case 'checkout.session.completed': {\n          const session = event.data.object;\n          \n          result = {\n            event: 'checkout.completed',\n            customerId: session.customer,\n            customerEmail: session.customer_email,\n            sessionId: session.id,\n            paymentIntentId: session.payment_intent,\n            subscriptionId: session.subscription,\n            amount: session.amount_total,\n            currency: session.currency,\n            metadata: session.metadata,\n            mode: session.mode,\n            status: session.status,\n            paymentStatus: session.payment_status\n          };\n          \n          break;\n        }\n        \n        case 'invoice.paid': {\n          const invoice = event.data.object;\n          \n          result = {\n            event: 'invoice.paid',\n            customerId: invoice.customer,\n            invoiceId: invoice.id,\n            subscriptionId: invoice.subscription,\n            amount: invoice.amount_paid,\n            currency: invoice.currency,\n            status: invoice.status,\n            paid: invoice.paid,\n            metadata: invoice.metadata\n          };\n          \n          break;\n        }\n        \n        case 'invoice.payment_failed': {\n          const invoice = event.data.object;\n          \n          result = {\n            event: 'invoice.payment_failed',\n            customerId: invoice.customer,\n            invoiceId: invoice.id,\n            subscriptionId: invoice.subscription,\n            amount: invoice.amount_due,\n            currency: invoice.currency,\n            status: invoice.status,\n            paid: invoice.paid,\n            metadata: invoice.metadata\n          };\n          \n          break;\n        }\n        \n        case 'customer.subscription.created': {\n          const subscription = event.data.object;\n          \n          result = {\n            event: 'subscription.created',\n            customerId: subscription.customer,\n            subscriptionId: subscription.id,\n            status: subscription.status,\n            currentPeriodStart: new Date(subscription.current_period_start * 1000).toISOString(),\n            currentPeriodEnd: new Date(subscription.current_period_end * 1000).toISOString(),\n            cancelAtPeriodEnd: subscription.cancel_at_period_end,\n            metadata: subscription.metadata\n          };\n          \n          break;\n        }\n        \n        case 'customer.subscription.updated': {\n          const subscription = event.data.object;\n          \n          result = {\n            event: 'subscription.updated',\n            customerId: subscription.customer,\n            subscriptionId: subscription.id,\n            status: subscription.status,\n            currentPeriodStart: new Date(subscription.current_period_start * 1000).toISOString(),\n            currentPeriodEnd: new Date(subscription.current_period_end * 1000).toISOString(),\n            cancelAtPeriodEnd: subscription.cancel_at_period_end,\n            canceledAt: subscription.canceled_at ? new Date(subscription.canceled_at * 1000).toISOString() : null,\n            metadata: subscription.metadata\n          };\n          \n          break;\n        }\n        \n        case 'customer.subscription.deleted': {\n          const subscription = event.data.object;\n          \n          result = {\n            event: 'subscription.deleted',\n            customerId: subscription.customer,\n            subscriptionId: subscription.id,\n            status: subscription.status,\n            canceledAt: subscription.canceled_at ? new Date(subscription.canceled_at * 1000).toISOString() : null,\n            metadata: subscription.metadata\n          };\n          \n          break;\n        }\n        \n        case 'payment_intent.succeeded': {\n          const paymentIntent = event.data.object;\n          \n          result = {\n            event: 'payment.succeeded',\n            customerId: paymentIntent.customer,\n            paymentIntentId: paymentIntent.id,\n            amount: paymentIntent.amount,\n            currency: paymentIntent.currency,\n            status: paymentIntent.status,\n            metadata: paymentIntent.metadata\n          };\n          \n          break;\n        }\n        \n        case 'payment_intent.payment_failed': {\n          const paymentIntent = event.data.object;\n          \n          result = {\n            event: 'payment.failed',\n            customerId: paymentIntent.customer,\n            paymentIntentId: paymentIntent.id,\n            amount: paymentIntent.amount,\n            currency: paymentIntent.currency,\n            status: paymentIntent.status,\n            error: paymentIntent.last_payment_error,\n            metadata: paymentIntent.metadata\n          };\n          \n          break;\n        }\n        \n        default: {\n          result = {\n            event: event.type,\n            data: event.data.object\n          };\n        }\n      }\n      \n      _log('Stripe webhook processed:', (result as any).event);\n\n      // Normalize to WebhookResult shape\n      return {\n        handled: true,\n        type: (result as any).event,\n        data: {\n          ...result,\n          provider: 'stripe',\n          originalEvent: event\n        }\n      };\n    } catch (error) {\n      _log('Error handling Stripe webhook:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Create a customer\n   * @param {Object} options - Customer options\n   * @param {string} options.email - Customer email\n   * @param {string} options.name - Customer name (optional)\n   * @param {Object} options.metadata - Additional metadata\n   * @returns {Promise<Object>} - Customer\n   */\n  async function createCustomer(options: Partial<Customer> & { email: string; name?: string; metadata?: Record<string, unknown> }): Promise<Customer> {\n    try {\n      _log('Creating Stripe customer:', options);\n      \n      // Validate required options\n      if (!options.email) {\n        throw new Error('Customer email is required');\n      }\n      \n      // Create customer\n      const customer = await stripe.customers.create({\n        email: options.email,\n        name: options.name,\n        metadata: options.metadata || {}\n      });\n      \n      _log('Stripe customer created:', customer.id);\n      \n      // Return a standardized response\n      return {\n        id: customer.id,\n        email: customer.email,\n        name: customer.name,\n        metadata: customer.metadata,\n        provider: 'stripe',\n        providerData: {\n          customerId: customer.id\n        }\n      };\n    } catch (error) {\n      _log('Error creating Stripe customer:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Get a customer\n   * @param {Object} options - Customer options\n   * @param {string} options.customerId - Customer ID\n   * @param {string} options.email - Customer email (optional)\n   * @returns {Promise<Object>} - Customer\n   */\n  async function getCustomer(options: { customerId?: string; email?: string }): Promise<Customer | null> {\n    try {\n      _log('Getting Stripe customer:', options);\n      \n      // Validate required options\n      if (!options.customerId && !options.email) {\n        throw new Error('Either customer ID or email is required');\n      }\n      \n      let customer;\n      \n      if (options.customerId) {\n        // Get customer by ID\n        customer = await stripe.customers.retrieve(options.customerId);\n      } else {\n        // Get customers by email\n        const customers = await stripe.customers.list({\n          email: options.email,\n          limit: 1\n        });\n        \n        if (customers.data.length === 0) {\n          return null;\n        }\n        \n        customer = customers.data[0];\n      }\n      \n      _log('Stripe customer retrieved:', customer.id);\n      \n      // Return a standardized response\n      return {\n        id: customer.id,\n        email: customer.email,\n        name: customer.name,\n        metadata: customer.metadata,\n        provider: 'stripe',\n        providerData: {\n          customerId: customer.id\n        }\n      };\n    } catch (error: unknown) {\n      _log('Error getting Stripe customer:', error);\n      const err = error as { code?: string };\n      // Return null for not found errors\n      if (err && err.code === 'resource_missing') {\n        return null;\n      }\n      throw (error instanceof Error ? error : new Error(String(error)));\n    }\n  }\n  \n  /**\n   * Update a customer\n   * @param {Object} options - Customer options\n   * @param {string} options.customerId - Customer ID\n   * @param {string} options.email - Customer email (optional)\n   * @param {string} options.name - Customer name (optional)\n   * @param {Object} options.metadata - Additional metadata\n   * @returns {Promise<Object>} - Updated customer\n   */\n  async function updateCustomer(options: { customerId: string; email?: string; name?: string; metadata?: Record<string, unknown> }): Promise<Customer> {\n    try {\n      _log('Updating Stripe customer:', options);\n      \n      // Validate required options\n      if (!options.customerId) {\n        throw new Error('Customer ID is required');\n      }\n      \n      // Prepare update parameters\n      const updateParams: Record<string, unknown> = {};\n      \n      if (options.email) {\n        updateParams.email = options.email;\n      }\n      \n      if (options.name) {\n        updateParams.name = options.name;\n      }\n      \n      if (options.metadata) {\n        updateParams.metadata = options.metadata;\n      }\n      \n      // Update customer\n      const customer = await stripe.customers.update(options.customerId, updateParams);\n      \n      _log('Stripe customer updated:', customer.id);\n      \n      // Return a standardized response\n      return {\n        id: customer.id,\n        email: customer.email,\n        name: customer.name,\n        metadata: customer.metadata,\n        provider: 'stripe',\n        providerData: {\n          customerId: customer.id\n        }\n      };\n    } catch (error) {\n      _log('Error updating Stripe customer:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Create a payment method\n   * @param {Object} options - Payment method options\n   * @param {string} options.customerId - Customer ID\n   * @param {string} options.type - Payment method type\n   * @param {Object} options.data - Payment method data\n   * @returns {Promise<Object>} - Payment method\n   */\n  async function createPaymentMethod(options: { customerId: string; type: string; data: Record<string, unknown> }): Promise<PaymentMethod> {\n    try {\n      _log('Creating Stripe payment method:', options);\n      \n      // Validate required options\n      if (!options.customerId) {\n        throw new Error('Customer ID is required');\n      }\n      \n      if (!options.type) {\n        throw new Error('Payment method type is required');\n      }\n      \n      if (!options.data) {\n        throw new Error('Payment method data is required');\n      }\n      \n      // Create payment method\n      const paymentMethod = await stripe.paymentMethods.create({\n        type: options.type,\n        [options.type]: options.data\n      });\n      \n      // Attach payment method to customer\n      await stripe.paymentMethods.attach(paymentMethod.id, {\n        customer: options.customerId\n      });\n      \n      _log('Stripe payment method created and attached:', paymentMethod.id);\n      \n      // Return a standardized response\n      return {\n        id: paymentMethod.id,\n        customerId: options.customerId,\n        type: paymentMethod.type,\n        provider: 'stripe',\n        providerData: {\n          paymentMethodId: paymentMethod.id\n        }\n      };\n    } catch (error) {\n      _log('Error creating Stripe payment method:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Get payment methods for a customer\n   * @param {Object} options - Payment method options\n   * @param {string} options.customerId - Customer ID\n   * @param {string} options.type - Payment method type (optional)\n   * @returns {Promise<Array>} - Payment methods\n   */\n  async function getPaymentMethods(options: { customerId: string; type?: string }): Promise<PaymentMethod[]> {\n    try {\n      _log('Getting Stripe payment methods:', options);\n      \n      // Validate required options\n      if (!options.customerId) {\n        throw new Error('Customer ID is required');\n      }\n      \n      // Get payment methods\n      const paymentMethods: { data: any[] } = await stripe.paymentMethods.list({\n        customer: options.customerId,\n        type: options.type\n      });\n      \n      _log('Stripe payment methods retrieved:', paymentMethods.data.length);\n      \n      // Return a standardized response\n      return paymentMethods.data.map((pm: any) => ({\n        id: pm.id,\n        customerId: options.customerId,\n        type: pm.type,\n        provider: 'stripe',\n        providerData: {\n          paymentMethodId: pm.id,\n          card: pm.card\n        }\n      }));\n    } catch (error) {\n      _log('Error getting Stripe payment methods:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Create a product\n   * @param {Object} options - Product options\n   * @param {string} options.name - Product name\n   * @param {string} options.description - Product description (optional)\n   * @param {Object} options.metadata - Additional metadata\n   * @returns {Promise<Object>} - Product\n   */\n  async function createProduct(options: Omit<Product, 'id'>): Promise<Product> {\n    try {\n      _log('Creating Stripe product:', options);\n      \n      // Validate required options\n      if (!options.name) {\n        throw new Error('Product name is required');\n      }\n      \n      // Create product\n      const product = await stripe.products.create({\n        name: options.name,\n        description: options.description,\n        metadata: options.metadata || {}\n      });\n      \n      _log('Stripe product created:', product.id);\n      \n      // Return a standardized response\n      return {\n        id: product.id,\n        name: product.name,\n        description: product.description,\n        metadata: product.metadata,\n        provider: 'stripe',\n        providerData: {\n          productId: product.id\n        }\n      };\n    } catch (error) {\n      _log('Error creating Stripe product:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Create a price\n   * @param {Object} options - Price options\n   * @param {string} options.productId - Product ID\n   * @param {string} options.currency - Currency code (default: USD)\n   * @param {number} options.unitAmount - Amount in smallest currency unit (e.g., cents)\n   * @param {string} options.interval - Billing interval (day, week, month, year)\n   * @param {number} options.intervalCount - Number of intervals (default: 1)\n   * @param {Object} options.metadata - Additional metadata\n   * @returns {Promise<Object>} - Price\n   */\n  async function createPrice(options: Omit<Price, 'id'> & { interval?: 'day' | 'week' | 'month' | 'year'; intervalCount?: number }): Promise<Price> {\n    try {\n      _log('Creating Stripe price:', options);\n      \n      // Validate required options\n      if (!options.productId) {\n        throw new Error('Product ID is required');\n      }\n      \n      if (!options.unitAmount) {\n        throw new Error('Unit amount is required');\n      }\n      \n      // Prepare price parameters\n      const normalizedCurrency = typeof options.currency === 'string' ? options.currency.toLowerCase() : 'usd';\n      const priceParams: Record<string, unknown> = {\n        product: options.productId,\n        currency: normalizedCurrency,\n        unit_amount: options.unitAmount,\n        metadata: options.metadata || {}\n      };\n      \n      // Add recurring parameters if interval is provided\n      if (options.interval) {\n        priceParams.recurring = {\n          interval: options.interval,\n          interval_count: options.intervalCount || 1\n        };\n      }\n      \n      // Create price\n      const price = await stripe.prices.create(priceParams);\n      \n      _log('Stripe price created:', price.id);\n      \n      // Return a standardized response\n      return {\n        id: price.id,\n        productId: price.product,\n        currency: price.currency,\n        unitAmount: price.unit_amount,\n        recurring: price.recurring ? {\n          interval: price.recurring.interval,\n          intervalCount: price.recurring.interval_count\n        } : null,\n        metadata: price.metadata,\n        provider: 'stripe',\n        providerData: {\n          priceId: price.id\n        }\n      };\n    } catch (error) {\n      _log('Error creating Stripe price:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Create a payment\n   * @param {Object} options - Payment options\n   * @param {string} options.customerId - Customer ID\n   * @param {number} options.amount - Amount in smallest currency unit (e.g., cents)\n   * @param {string} options.currency - Currency code (default: USD)\n   * @param {string} options.description - Payment description (optional)\n   * @param {Object} options.metadata - Additional metadata\n   * @returns {Promise<Object>} - Payment\n   */\n  async function createPayment(options: { amount: number; currency: string; customerId?: string; metadata?: Record<string, unknown> }): Promise<PaymentResult> {\n    try {\n      _log('Creating Stripe payment:', options);\n      \n      // Validate required options\n      if (!options.amount) {\n        throw new Error('Amount is required');\n      }\n      \n      // Create payment intent\n      const paymentIntent = await stripe.paymentIntents.create({\n        amount: options.amount,\n        currency: options.currency.toLowerCase(),\n        customer: options.customerId,\n        metadata: options.metadata || {},\n        confirm: false\n      });\n      \n      _log('Stripe payment intent created:', paymentIntent.id);\n      \n      // Return a standardized response\n      return {\n        id: paymentIntent.id,\n        customerId: paymentIntent.customer,\n        amount: paymentIntent.amount,\n        currency: paymentIntent.currency,\n        description: paymentIntent.description,\n        status: paymentIntent.status,\n        clientSecret: paymentIntent.client_secret,\n        metadata: paymentIntent.metadata,\n        provider: 'stripe',\n        providerData: {\n          paymentIntentId: paymentIntent.id\n        }\n      };\n    } catch (error) {\n      _log('Error creating Stripe payment:', error);\n      throw error;\n    }\n  }\n  \n  \n  \n  /**\n   * Log debug messages\n   * @param {...any} args - Arguments to log\n   * @private\n   */\n  function _log(...args: unknown[]): void {\n    if (config.debug) {\n      console.log('[StripeProvider]', ...args);\n    }\n  }\n  \n  // Return the provider\n  return {\n    createCheckoutSession,\n    createSubscription,\n    getSubscription,\n    cancelSubscription,\n    handleWebhook,\n    createCustomer,\n    getCustomer,\n    updateCustomer,\n    createPaymentMethod,\n    getPaymentMethods,\n    createProduct,\n    createPrice,\n    createPayment,\n    // Usage metering (Stripe metered billing)\n    async recordUsage(options: UsageRecordOptions): Promise<UsageRecordResult> {\n      try {\n        _log('Recording Stripe usage:', options);\n        if (!options.subscriptionItemId) {\n          throw new Error('subscriptionItemId is required to record usage in Stripe');\n        }\n        if (typeof options.quantity !== 'number') {\n          throw new Error('quantity is required');\n        }\n        const ts = options.timestamp ? Math.floor(new Date(options.timestamp).getTime() / 1000) : Math.floor(Date.now() / 1000);\n        const usageRecord = await stripe.usageRecords.create({\n          subscription_item: options.subscriptionItemId,\n          quantity: options.quantity,\n          timestamp: ts,\n          action: 'increment'\n        }, { idempotencyKey: options.idempotencyKey });\n        return { id: usageRecord.id, success: true, provider: 'stripe', providerData: { usageRecordId: usageRecord.id } };\n      } catch (error: unknown) {\n        _log('Error recording Stripe usage:', error);\n        throw (error instanceof Error ? error : new Error(String(error)));\n      }\n    }\n  };\n}\n\nexport default createStripeProvider;"]}