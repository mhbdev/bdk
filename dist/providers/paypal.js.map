{"version":3,"sources":["../../src/providers/paypal.ts"],"names":["options","eventData"],"mappings":"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","file":"paypal.js","sourcesContent":["/**\n * PayPal provider for @mhbdev/bdk\n */\n\n/**\n * Create a PayPal provider\n * @param {Object} options - PayPal options\n * @param {string} options.clientId - PayPal client ID\n * @param {string} options.clientSecret - PayPal client secret\n * @param {boolean} options.sandbox - Whether to use sandbox environment (default: false)\n * @param {Object} options.webhookId - PayPal webhook ID for verification\n * @returns {Object} PayPal provider\n */\nimport type { PaymentProvider, WebhookOptions, WebhookResult, SubscriptionOptions, Subscription, GetSubscriptionOptions } from '../types';\n\ninterface PayPalProviderOptions {\n  clientId: string;\n  clientSecret: string;\n  sandbox?: boolean;\n  webhookId?: string | null;\n  debug?: boolean;\n}\n\ninterface PayPalLink { rel: string; href: string; }\ninterface PayPalOrder {\n  id: string;\n  status?: string;\n  links: PayPalLink[];\n}\ninterface PayPalSubscription {\n  id: string;\n  status?: string;\n  start_time?: string;\n  plan_id?: string;\n  subscriber?: { email_address?: string };\n  billing_info?: { next_billing_time?: string };\n  custom_id?: string | null;\n  links?: PayPalLink[];\n}\ninterface PayPalWebhookEvent {\n  id: string;\n  event_type: string;\n  create_time: string;\n  resource_type?: string;\n  resource?: unknown;\n}\n\nexport function createPayPalProvider(options: PayPalProviderOptions): PaymentProvider {\n  // Validate required options\n  if (!options.clientId) {\n    throw new Error('PayPal client ID is required');\n  }\n\n  if (!options.clientSecret) {\n    throw new Error('PayPal client secret is required');\n  }\n\n  // Configuration\n  const config = {\n    clientId: options.clientId,\n    clientSecret: options.clientSecret,\n    sandbox: options.sandbox !== false,\n    webhookId: options.webhookId || null,\n    debug: options.debug || false\n  };\n\n  // API base URL based on environment\n  const baseUrl = config.sandbox\n    ? 'https://api-m.sandbox.paypal.com'\n    : 'https://api-m.paypal.com';\n\n  // Cache for access token\n  let accessToken: string | null = null;\n  let tokenExpiry: number | null = null;\n\n  /**\n   * Get access token for API calls\n   * @private\n   * @returns {Promise<string>} Access token\n   */\n  async function getAccessToken(): Promise<string> {\n    // Check if we have a valid token\n    if (accessToken && tokenExpiry && Date.now() < tokenExpiry) {\n      return accessToken;\n    }\n\n    // Request new token\n    const auth = Buffer.from(`${config.clientId}:${config.clientSecret}`).toString('base64');\n    \n    const response = await fetch(`${baseUrl}/v1/oauth2/token`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n        'Authorization': `Basic ${auth}`\n      },\n      body: 'grant_type=client_credentials'\n    });\n\n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(`PayPal authentication failed: ${error.error_description || 'Unknown error'}`);\n    }\n\n    const data = await response.json();\n    \n    // Cache token\n    accessToken = data.access_token;\n    tokenExpiry = Date.now() + (data.expires_in * 1000) - 60000; // Subtract 1 minute for safety\n    \n    return accessToken as string;\n  }\n\n  /**\n   * Make authenticated API request to PayPal\n   * @private\n   * @param {string} endpoint - API endpoint\n   * @param {string} method - HTTP method\n   * @param {Object} body - Request body\n   * @returns {Promise<Object>} Response data\n   */\n  async function apiRequest<T = any>(endpoint: string, method: 'GET' | 'POST' | 'PUT' | 'PATCH' = 'GET', body: unknown = null): Promise<T> {\n    const token = await getAccessToken();\n    \n    const headers: Record<string, string> = {\n      'Content-Type': 'application/json',\n      'Authorization': `Bearer ${token}`\n    };\n\n    const options: RequestInit = { method, headers };\n\n    if (body && (method === 'POST' || method === 'PUT' || method === 'PATCH')) {\n      options.body = JSON.stringify(body);\n    }\n\n    const response = await fetch(`${baseUrl}${endpoint}`, options);\n    \n    const responseData = await response.json();\n    \n    if (!response.ok) {\n      const errorMessage = responseData.message || responseData.error_description || 'Unknown error';\n      throw new Error(`PayPal API error: ${errorMessage}`);\n    }\n    \n    return responseData;\n  }\n\n  /**\n   * Create a checkout session\n   * @param {Object} options - Checkout options\n   * @returns {Promise<Object>} Checkout session\n   */\n  async function createCheckoutSession(options: {\n    customerId?: string;\n    customerEmail?: string;\n    priceId?: string;\n    productId?: string;\n    successUrl: string;\n    cancelUrl: string;\n    metadata?: Record<string, unknown>;\n    mode?: 'payment' | 'subscription';\n    currency?: string;\n    amount?: number;\n  }) {\n    const {\n      customerEmail,\n      priceId,\n      productId,\n      successUrl,\n      cancelUrl,\n      metadata = {},\n      mode = 'payment',\n      currency = 'USD',\n      amount\n    } = options;\n\n    // Validate required options\n    if (!successUrl) {\n      throw new Error('Success URL is required');\n    }\n\n    if (!cancelUrl) {\n      throw new Error('Cancel URL is required');\n    }\n\n    // Create order based on mode\n    if (mode === 'payment') {\n      // One-time payment\n      if (!amount) {\n        throw new Error('Amount is required for payment mode');\n      }\n\n      const brandName = typeof (metadata as any).brandName === 'string' ? (metadata as any).brandName : 'Your Store';\n      const orderData: any = {\n        intent: 'CAPTURE',\n        purchase_units: [\n          {\n            amount: {\n              currency_code: currency.toUpperCase(),\n              value: (amount / 100).toFixed(2) // Convert from cents to dollars\n            },\n            description: metadata.description || 'Payment'\n          }\n        ],\n        application_context: {\n          return_url: successUrl,\n          cancel_url: cancelUrl,\n          brand_name: brandName,\n          user_action: 'PAY_NOW'\n        }\n      };\n\n      // Add customer info if available\n      if (customerEmail) {\n        orderData.payer = {\n          email_address: customerEmail\n        };\n      }\n\n      // Create order\n      const order = await apiRequest<PayPalOrder>('/v2/checkout/orders', 'POST', orderData);\n\n      // Find approval URL\n      const approval = order.links.find(link => link.rel === 'approve');\n      const approvalUrl = approval ? approval.href : '';\n\n      return {\n        id: order.id,\n        url: approvalUrl,\n        status: order.status,\n        mode: 'payment',\n        metadata\n      };\n    } else if (mode === 'subscription') {\n      // Subscription\n      if (!priceId && !productId) {\n        throw new Error('Price ID or Product ID is required for subscription mode');\n      }\n\n      // Create subscription plan if not provided\n      let planId = priceId;\n      \n      if (!planId && productId) {\n        // TODO: Create plan from product\n        throw new Error('Creating plans from products is not implemented yet');\n      }\n\n      // Create subscription\n      const subBrandName = typeof (metadata as any).brandName === 'string' ? (metadata as any).brandName : 'Your Store';\n      const subscriptionData: any = {\n        plan_id: planId,\n        application_context: {\n          return_url: successUrl,\n          cancel_url: cancelUrl,\n          brand_name: subBrandName,\n          user_action: 'SUBSCRIBE_NOW'\n        }\n      };\n\n      // Add customer info if available\n      if (customerEmail) {\n        subscriptionData.subscriber = {\n          email_address: customerEmail\n        };\n      }\n\n      // Create subscription\n      const subscription = await apiRequest<PayPalSubscription>('/v1/billing/subscriptions', 'POST', subscriptionData);\n\n      // Find approval URL\n      const approval = (subscription.links || []).find(link => link.rel === 'approve');\n      const approvalUrl = approval ? approval.href : '';\n\n      return {\n        id: subscription.id,\n        url: approvalUrl,\n        status: subscription.status,\n        mode: 'subscription',\n        metadata\n      };\n    } else {\n      throw new Error(`Unsupported checkout mode: ${mode}`);\n    }\n  }\n\n  /**\n   * Create a subscription\n   * @param {Object} options - Subscription options\n   * @returns {Promise<Object>} Subscription\n   */\n  async function createSubscription(options: SubscriptionOptions) {\n    const {\n      customerId,\n      customerEmail,\n      priceId,\n      planId,\n      metadata = {}\n    } = options;\n\n    // Validate required options\n    if (!customerEmail) {\n      throw new Error('Customer email is required');\n    }\n    if (!priceId && !planId) {\n      throw new Error('Price ID or Plan ID is required');\n    }\n\n    // Customer email is optional; approval flow may collect it\n\n    // Use provided plan ID or price ID\n    const subscriptionPlanId = planId || priceId;\n\n    // Create subscription\n    const subCreateBrandName = typeof (metadata as any).brandName === 'string' ? (metadata as any).brandName : 'Your Store';\n    const subscriptionData: Record<string, unknown> = {\n      plan_id: subscriptionPlanId,\n      application_context: {\n        brand_name: subCreateBrandName,\n        user_action: 'SUBSCRIBE_NOW'\n      }\n    };\n    if (customerEmail) {\n      (subscriptionData as any).subscriber = { email_address: customerEmail };\n    }\n\n    // Create subscription\n    const subscription = await apiRequest<PayPalSubscription>('/v1/billing/subscriptions', 'POST', subscriptionData);\n\n    return {\n      id: subscription.id,\n      status: subscription.status,\n      customerId: (customerId || subscription.subscriber?.email_address || ''),\n      // Standard fields\n      currentPeriodStart: subscription.start_time,\n      currentPeriodEnd: subscription.billing_info?.next_billing_time || undefined,\n      metadata,\n      // Extended convenience fields expected by tests\n      planId: subscriptionPlanId,\n      startDate: subscription.start_time,\n      endDate: subscription.billing_info?.next_billing_time\n    };\n  }\n\n  /**\n   * Get a subscription\n   * @param {Object} options - Subscription options\n   * @returns {Promise<Object>} Subscription\n   */\n  async function getSubscription(options: GetSubscriptionOptions): Promise<Subscription | null> {\n    const { subscriptionId } = options;\n\n    // Validate required options\n    if (!subscriptionId) {\n      throw new Error('Subscription ID is required');\n    }\n\n    // Get subscription\n    const subscription = await apiRequest<PayPalSubscription>(`/v1/billing/subscriptions/${subscriptionId}`);\n\n    // Parse custom_id metadata if present and valid JSON\n    let parsedMeta: Record<string, unknown> = {};\n    if (subscription.custom_id) {\n      try {\n        parsedMeta = JSON.parse(subscription.custom_id);\n      } catch {\n        parsedMeta = {};\n      }\n    }\n\n    return {\n      id: subscription.id,\n      status: subscription.status,\n      customerId: subscription.subscriber?.email_address || '',\n      currentPeriodStart: subscription.start_time,\n      currentPeriodEnd: subscription.billing_info?.next_billing_time || undefined,\n      metadata: parsedMeta,\n      // Extended convenience fields expected by tests\n      planId: subscription.plan_id,\n      startDate: subscription.start_time,\n      endDate: subscription.billing_info?.next_billing_time\n    };\n  }\n\n  /**\n   * Cancel a subscription\n   * @param {Object} options - Subscription options\n   * @returns {Promise<Object>} Cancellation result\n   */\n  async function cancelSubscription(options: { subscriptionId: string; atPeriodEnd?: boolean; reason?: string }) {\n    const { subscriptionId, atPeriodEnd = false, reason = 'Canceled by customer' } = options;\n\n    // Validate required options\n    if (!subscriptionId) {\n      throw new Error('Subscription ID is required');\n    }\n\n    // Cancel subscription\n    if (atPeriodEnd) {\n      // Suspend subscription (will be canceled at period end)\n      await apiRequest(`/v1/billing/subscriptions/${subscriptionId}/suspend`, 'POST', { reason });\n\n      return {\n        id: subscriptionId,\n        status: 'SUSPENDED',\n        canceledAt: new Date().toISOString(),\n        cancelAtPeriodEnd: true\n      };\n    } else {\n      // Cancel subscription immediately\n      await apiRequest(`/v1/billing/subscriptions/${subscriptionId}/cancel`, 'POST', { reason });\n\n      return {\n        id: subscriptionId,\n        status: 'CANCELED',\n        canceledAt: new Date().toISOString(),\n        cancelAtPeriodEnd: false\n      };\n    }\n  }\n\n  /**\n   * Handle a webhook event\n   * @param {Object} options - Webhook options\n   * @returns {Promise<Object>} Webhook handling result\n   */\n  async function handleWebhook(options: WebhookOptions): Promise<WebhookResult> {\n    const { body, signature } = options;\n\n    // Parse webhook event\n    let event;\n    try {\n      // Parse body if it's a string\n      const eventData: PayPalWebhookEvent = typeof body === 'string' ? JSON.parse(body) : (body as PayPalWebhookEvent);\n      \n      // Verify webhook signature if webhook ID is provided\n      if (config.webhookId && signature) {\n        // TODO: Implement webhook signature verification\n        // This would require the PayPal webhook ID and the webhook signature\n      }\n      \n      event = eventData;\n    } catch (error) {\n      throw new Error(`Invalid webhook payload: ${(error as any).message}`);\n    }\n\n    // Map PayPal event types to standardized event types\n    const eventTypeMap: Record<string, string> = {\n      'PAYMENT.SALE.COMPLETED': 'payment.succeeded',\n      'PAYMENT.SALE.REFUNDED': 'payment.refunded',\n      'PAYMENT.SALE.REVERSED': 'payment.disputed',\n      'BILLING.SUBSCRIPTION.CREATED': 'subscription.created',\n      'BILLING.SUBSCRIPTION.ACTIVATED': 'subscription.activated',\n      'BILLING.SUBSCRIPTION.UPDATED': 'subscription.updated',\n      'BILLING.SUBSCRIPTION.CANCELLED': 'subscription.canceled',\n      'BILLING.SUBSCRIPTION.SUSPENDED': 'subscription.paused',\n      'BILLING.SUBSCRIPTION.PAYMENT.FAILED': 'invoice.payment_failed'\n    };\n\n    // Get standardized event type\n    const standardizedEventType = eventTypeMap[event.event_type] || event.event_type;\n\n    // Extract relevant data based on event type\n    let eventData: { id?: string; object?: string; created?: number; data?: { object: unknown } } = {};\n    \n    if (event.resource) {\n      const resource: any = event.resource as any;\n      eventData = {\n        id: resource.id,\n        object: (event.resource_type || '').toLowerCase(),\n        created: new Date(event.create_time).getTime() / 1000,\n        data: {\n          object: resource\n        }\n      };\n    }\n\n    // Prefer exposing key identifiers at top-level for tests\n    const resourceId = (event.resource && (event.resource as any).id) ? (event.resource as any).id : undefined;\n    return {\n      handled: true,\n      type: standardizedEventType,\n      id: event.id,\n      event: standardizedEventType,\n      data: {\n        id: resourceId,\n        event: standardizedEventType,\n        payload: eventData,\n        created: new Date(event.create_time).getTime() / 1000,\n        provider: 'paypal',\n        originalEvent: event\n      }\n    };\n  }\n\n  // Return provider interface\n  return {\n    createCheckoutSession,\n    createSubscription,\n    getSubscription,\n    cancelSubscription,\n    handleWebhook\n  };\n}\n\nexport default createPayPalProvider;"]}