{"version":3,"sources":["../../src/usage/storage.ts","../../src/providers/mock.ts"],"names":["options","customer"],"mappings":"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","file":"mock.js","sourcesContent":["import type { UsageEvent, UsagePolicy, UsageStorageAdapter } from '../types';\n\n// Simple in-memory storage adapter implementation\nexport class InMemoryUsageStorageAdapter implements UsageStorageAdapter {\n  private events: Map<string, UsageEvent[]> = new Map();\n  private policies: Map<string, UsagePolicy> = new Map();\n  // Map of composite key `${key}:${idempotencyKey}` to { eventId, ts }\n  private idempotencyIndex: Map<string, { eventId: string; ts: number }> = new Map();\n  private idempotencyTtlMs?: number;\n\n  constructor(options?: { idempotencyTtlMs?: number }) {\n    this.idempotencyTtlMs = options?.idempotencyTtlMs;\n  }\n\n  private cleanupIdempotency(now: number) {\n    if (!this.idempotencyTtlMs) return;\n    const ttl = this.idempotencyTtlMs;\n    for (const [k, v] of this.idempotencyIndex.entries()) {\n      if (now - v.ts > ttl) {\n        this.idempotencyIndex.delete(k);\n      }\n    }\n  }\n\n  async getEvents(key: string): Promise<UsageEvent[]> {\n    return this.events.get(key) || [];\n  }\n\n  async addEvent(key: string, event: UsageEvent, idempotencyKey?: string): Promise<{ inserted: boolean }> {\n    const now = Date.now();\n    this.cleanupIdempotency(now);\n    if (idempotencyKey) {\n      const idemKey = `${key}:${idempotencyKey}`;\n      const existing = this.idempotencyIndex.get(idemKey);\n      if (existing) {\n        // Existing idempotency key still valid\n        return { inserted: false };\n      }\n      this.idempotencyIndex.set(idemKey, { eventId: event.id, ts: now });\n    }\n    const arr = this.events.get(key) || [];\n    arr.push(event);\n    this.events.set(key, arr);\n    return { inserted: true };\n  }\n\n  async getPolicy(key: string): Promise<UsagePolicy | null> {\n    return this.policies.get(key) || null;\n  }\n\n  async setPolicy(key: string, policy: UsagePolicy): Promise<void> {\n    this.policies.set(key, policy);\n  }\n}\n\nexport default InMemoryUsageStorageAdapter;","/**\n * Mock Provider for Payment Gateway\n * \n * Implements a mock payment provider for testing purposes.\n */\n\nimport crypto from 'crypto';\nimport type {\n  PaymentProvider,\n  WebhookOptions,\n  WebhookResult,\n  CheckoutOptions,\n  CheckoutSession,\n  SubscriptionOptions,\n  Subscription,\n  GetSubscriptionOptions,\n  CancelSubscriptionOptions,\n  Customer,\n  Product,\n  Price,\n  SubscriptionItem,\n  // Usage metering types\n  UsageEvent,\n  UsageRecordOptions,\n  UsageRecordResult,\n  UsageQueryOptions,\n  UsageAggregateOptions,\n  UsageAggregate,\n  UsagePolicy,\n  UsagePolicyOptions,\n  UsageLimitCheckOptions,\n  UsageLimitResult\n} from '../types';\nimport { InMemoryUsageStorageAdapter } from '../usage/storage';\nimport type { UsageStorageAdapter } from '../types';\n\n/**\n * Create a Mock provider\n * @param {Object} options - Configuration options\n * @param {boolean} options.simulateErrors - Whether to simulate errors\n * @param {number} options.errorRate - Error rate (0-1)\n * @param {number} options.delay - Delay in milliseconds\n * @param {boolean} options.debug - Enable debug mode\n * @returns {Object} - Mock provider\n */\ninterface MockProviderOptions {\n  simulateErrors: boolean;\n  errorRate: number;\n  delay: number;\n  debug: boolean;\n  usageStorage?: UsageStorageAdapter;\n  usageIdempotencyTtlMs?: number;\n}\n\ninterface MockSession {\n  id: string;\n  customerId?: string;\n  customerEmail?: string;\n  mode: 'payment' | 'subscription' | 'setup' | string;\n  amount: number;\n  currency: string;\n  priceId?: string;\n  status: string;\n  paymentStatus: string;\n  successUrl?: string;\n  cancelUrl?: string;\n  metadata: Record<string, unknown>;\n  createdAt: string;\n  expiresAt: string;\n  subscriptionId?: string;\n}\n\ninterface MockPrice extends Price {\n  recurring?: { interval: 'day' | 'week' | 'month' | 'year'; intervalCount: number };\n  createdAt: string;\n}\n\ninterface MockProduct extends Product { createdAt: string }\n\ninterface MockSubscription extends Subscription {\n  priceId?: string;\n  createdAt: string;\n  items: SubscriptionItem[];\n}\n\nexport function createMockProvider(options: Partial<MockProviderOptions> = {}): PaymentProvider {\n  // Default options\n  const config: MockProviderOptions = {\n    simulateErrors: false,\n    errorRate: 0.1,\n    delay: 500,\n    debug: false,\n    ...options\n  };\n  \n  // (Removed) event emitter; not used in typed provider\n  \n  // In-memory storage for subscriptions, payments, and customers\n  const subscriptions: Map<string, MockSubscription> = new Map();\n  const payments: Map<string, MockSession> = new Map();\n  const customers: Map<string, Customer> = new Map();\n  const products: Map<string, MockProduct> = new Map();\n  const prices: Map<string, MockPrice> = new Map();\n  // Usage storage adapter (pluggable, defaults to in-memory)\n  const usageStorage: UsageStorageAdapter = config.usageStorage ?? new InMemoryUsageStorageAdapter({ idempotencyTtlMs: config.usageIdempotencyTtlMs });\n\n  function usageKey(customerId: string, metricKey: string): string {\n    return `${customerId}:${metricKey}`;\n  }\n\n  function inRange(tsIso: string, start?: string, end?: string): boolean {\n    const ts = new Date(tsIso).getTime();\n    if (start && ts < new Date(start).getTime()) return false;\n    if (end && ts > new Date(end).getTime()) return false;\n    return true;\n  }\n  \n  /**\n   * Create a checkout session\n   * @param {Object} options - Checkout options\n   * @param {string} options.customerId - Customer ID (optional)\n   * @param {string} options.customerEmail - Customer email (optional)\n   * @param {string} options.priceId - Price ID\n   * @param {string} options.successUrl - Success URL\n   * @param {string} options.cancelUrl - Cancel URL\n   * @param {Object} options.metadata - Additional metadata\n   * @param {string} options.mode - Checkout mode (payment, subscription, setup)\n   * @param {string} options.currency - Currency code (default: USD)\n   * @param {number} options.amount - Amount in smallest currency unit (e.g., cents)\n   * @returns {Promise<Object>} - Checkout session\n   */\n  async function createCheckoutSession(options: CheckoutOptions = {}): Promise<CheckoutSession> {\n    try {\n      _log('Creating mock checkout session:', options);\n      \n      // Simulate delay\n      await _delay(config.delay);\n      \n      // Simulate error\n      if (_shouldSimulateError()) {\n        throw new Error('Simulated error creating checkout session');\n      }\n      \n      // Create a unique session ID\n      const sessionId = `mock_session_${Date.now()}_${crypto.randomBytes(4).toString('hex')}`;\n      \n      // Get customer ID or create a new one\n      let customerId = options.customerId;\n      \n      if (!customerId && options.customerEmail) {\n        // Check if customer exists\n        for (const [id, customer] of customers.entries()) {\n          if (customer.email === options.customerEmail) {\n            customerId = id;\n            break;\n          }\n        }\n        \n        // Create new customer if not found\n        if (!customerId) {\n          customerId = `mock_cus_${Date.now()}_${crypto.randomBytes(4).toString('hex')}`;\n          \n          customers.set(customerId, {\n            id: customerId,\n            email: options.customerEmail,\n            name: undefined,\n            metadata: {} as Record<string, unknown>\n          });\n        }\n      }\n      \n      // Create checkout session\n      const session: MockSession = {\n        id: sessionId,\n        customerId,\n        customerEmail: options.customerEmail as string | undefined,\n        mode: (options.mode as MockSession['mode']) || 'payment',\n        amount: (options.amount as number) || 1000,\n        currency: ((options.currency as string) || 'usd').toLowerCase(),\n        priceId: options.priceId as string | undefined,\n        status: 'pending',\n        paymentStatus: 'unpaid',\n        successUrl: options.successUrl as string | undefined,\n        cancelUrl: options.cancelUrl as string | undefined,\n        metadata: (options.metadata as Record<string, unknown>) || {},\n        createdAt: new Date().toISOString(),\n        expiresAt: new Date(Date.now() + 30 * 60 * 1000).toISOString() // 30 minutes\n      };\n      \n      // Store session\n      payments.set(sessionId, session);\n      \n      _log('Mock checkout session created:', sessionId);\n      \n      // Return a standardized response\n      return {\n        id: session.id,\n        url: `https://mock-payment-gateway.com/checkout/${sessionId}`,\n        status: session.status,\n        customerId: session.customerId,\n        customerEmail: session.customerEmail,\n        mode: session.mode,\n        paymentStatus: session.paymentStatus,\n        amountTotal: session.amount,\n        currency: session.currency,\n        metadata: session.metadata,\n        expiresAt: session.expiresAt,\n        provider: 'mock',\n        providerData: {\n          sessionId: session.id\n        }\n      };\n    } catch (error) {\n      _log('Error creating mock checkout session:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Create a subscription\n   * @param {Object} options - Subscription options\n   * @param {string} options.customerId - Customer ID\n   * @param {string} options.priceId - Price ID\n   * @param {Object} options.metadata - Additional metadata\n   * @param {string} options.paymentMethodId - Payment method ID (optional)\n   * @returns {Promise<Object>} - Subscription\n   */\n  async function createSubscription(options: SubscriptionOptions): Promise<Subscription> {\n    try {\n      _log('Creating mock subscription:', options);\n      \n      // Simulate delay\n      await _delay(config.delay);\n      \n      // Simulate error\n      if (_shouldSimulateError()) {\n        throw new Error('Simulated error creating subscription');\n      }\n      \n      // Validate required options\n      if (!options.customerId) {\n        throw new Error('Customer ID is required');\n      }\n      \n      // Check if customer exists\n      if (!customers.has(options.customerId)) {\n        throw new Error(`Customer ${options.customerId} not found`);\n      }\n      \n      // Create a unique subscription ID\n      const subscriptionId = `mock_sub_${Date.now()}_${crypto.randomBytes(4).toString('hex')}`;\n      \n      // Get price details\n      let interval: 'day' | 'week' | 'month' | 'year' = 'month';\n      let intervalCount = 1;\n      \n      if (options.priceId && prices.has(options.priceId as string)) {\n        const price = prices.get(options.priceId as string)!;\n        if (price.recurring) {\n          interval = price.recurring.interval;\n          intervalCount = price.recurring.intervalCount;\n        }\n      }\n      \n      // Calculate period dates\n      const now = new Date();\n      const periodEnd = new Date(now);\n      \n      if (interval === 'day') {\n        periodEnd.setDate(periodEnd.getDate() + intervalCount);\n      } else if (interval === 'week') {\n        periodEnd.setDate(periodEnd.getDate() + (7 * intervalCount));\n      } else if (interval === 'month') {\n        periodEnd.setMonth(periodEnd.getMonth() + intervalCount);\n      } else if (interval === 'year') {\n        periodEnd.setFullYear(periodEnd.getFullYear() + intervalCount);\n      }\n      \n      // Create subscription\n      const subscription: MockSubscription = {\n        id: subscriptionId,\n        customerId: options.customerId,\n        priceId: options.priceId as string | undefined,\n        status: 'active',\n        currentPeriodStart: now.toISOString(),\n        currentPeriodEnd: periodEnd.toISOString(),\n        cancelAtPeriodEnd: false,\n        canceledAt: null,\n        metadata: (options.metadata as Record<string, unknown>) || {},\n        createdAt: now.toISOString(),\n        items: [\n          {\n            id: `mock_si_${Date.now()}_${crypto.randomBytes(4).toString('hex')}`,\n            priceId: options.priceId as string,\n            quantity: 1\n          }\n        ]\n      };\n      \n      // Store subscription\n      subscriptions.set(subscriptionId, subscription);\n      \n      _log('Mock subscription created:', subscriptionId);\n      \n      // Return a standardized response\n      return {\n        id: subscription.id,\n        customerId: subscription.customerId,\n        status: subscription.status,\n        currentPeriodStart: subscription.currentPeriodStart,\n        currentPeriodEnd: subscription.currentPeriodEnd,\n        cancelAtPeriodEnd: subscription.cancelAtPeriodEnd,\n        canceledAt: subscription.canceledAt,\n        metadata: subscription.metadata,\n        items: subscription.items,\n        provider: 'mock',\n        providerData: {\n          subscriptionId: subscription.id\n        }\n      };\n    } catch (error) {\n      _log('Error creating mock subscription:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Get a subscription\n   * @param {Object} options - Subscription options\n   * @param {string} options.subscriptionId - Subscription ID\n   * @param {string} options.customerId - Customer ID (optional)\n   * @returns {Promise<Object>} - Subscription\n   */\n  async function getSubscription(options: GetSubscriptionOptions): Promise<Subscription | null> {\n    try {\n      _log('Getting mock subscription:', options);\n      \n      // Simulate delay\n      await _delay(config.delay);\n      \n      // Simulate error\n      if (_shouldSimulateError()) {\n        throw new Error('Simulated error getting subscription');\n      }\n      \n      // Validate required options\n      if (!options.subscriptionId && !options.customerId) {\n        throw new Error('Either subscription ID or customer ID is required');\n      }\n      \n      let subscription: MockSubscription | undefined;\n      \n      if (options.subscriptionId) {\n        // Get subscription by ID\n        subscription = subscriptions.get(options.subscriptionId);\n        \n        if (!subscription) {\n          return null;\n        }\n      } else {\n        // Get subscriptions for customer\n        const customerSubscriptions = Array.from(subscriptions.values())\n          .filter(sub => sub.customerId === options.customerId)\n          .sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());\n        \n        if (customerSubscriptions.length === 0) {\n          return null;\n        }\n        \n        subscription = customerSubscriptions[0];\n      }\n      \n      if (!subscription) {\n        return null;\n      }\n\n      _log('Mock subscription retrieved:', subscription.id);\n      \n      // Return a standardized response\n      return {\n        id: subscription.id,\n        customerId: subscription.customerId,\n        status: subscription.status,\n        currentPeriodStart: subscription.currentPeriodStart,\n        currentPeriodEnd: subscription.currentPeriodEnd,\n        cancelAtPeriodEnd: subscription.cancelAtPeriodEnd,\n        canceledAt: subscription.canceledAt,\n        metadata: subscription.metadata,\n        items: subscription.items,\n        provider: 'mock',\n        providerData: {\n          subscriptionId: subscription.id\n        }\n      };\n    } catch (error) {\n      _log('Error getting mock subscription:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Cancel a subscription\n   * @param {Object} options - Subscription options\n   * @param {string} options.subscriptionId - Subscription ID\n   * @param {boolean} options.atPeriodEnd - Whether to cancel at the end of the billing period\n   * @returns {Promise<Object>} - Cancellation result\n   */\n  async function cancelSubscription(options: CancelSubscriptionOptions): Promise<unknown> {\n    try {\n      _log('Canceling mock subscription:', options);\n      \n      // Simulate delay\n      await _delay(config.delay);\n      \n      // Simulate error\n      if (_shouldSimulateError()) {\n        throw new Error('Simulated error canceling subscription');\n      }\n      \n      // Validate required options\n      if (!options.subscriptionId) {\n        throw new Error('Subscription ID is required');\n      }\n      \n      // Get subscription\n      const subscription = subscriptions.get(options.subscriptionId);\n      \n      if (!subscription) {\n        throw new Error(`Subscription ${options.subscriptionId} not found`);\n      }\n      \n      // Update subscription\n      if (options.atPeriodEnd) {\n        subscription.cancelAtPeriodEnd = true;\n      } else {\n        subscription.status = 'canceled';\n        subscription.canceledAt = new Date().toISOString();\n      }\n      \n      _log('Mock subscription canceled:', subscription.id);\n      \n      // Return a standardized response\n      return {\n        id: subscription.id,\n        status: subscription.status,\n        cancelAtPeriodEnd: subscription.cancelAtPeriodEnd,\n        canceledAt: subscription.canceledAt,\n        provider: 'mock',\n        success: true\n      };\n    } catch (error) {\n      _log('Error canceling mock subscription:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Handle a webhook event\n   * @param {Object} options - Webhook options\n   * @param {string} options.body - Webhook body\n   * @param {Object} options.headers - Webhook headers\n   * @returns {Promise<Object>} - Webhook handling result\n   */\n  async function handleWebhook(options: WebhookOptions): Promise<WebhookResult> {\n    try {\n      _log('Handling mock webhook:', options);\n      \n      // Simulate delay\n      await _delay(config.delay);\n      \n      // Simulate error\n      if (_shouldSimulateError()) {\n        throw new Error('Simulated error handling webhook');\n      }\n      \n      // Parse webhook body\n      const body: any = typeof options.body === 'string' ? JSON.parse(options.body) : options.body;\n      \n      // Validate webhook data\n      if (!body.type || !body.data) {\n        throw new Error('Invalid webhook data');\n      }\n      \n      let result: any;\n      \n      // Process webhook based on type\n      switch (body.type) {\n        case 'checkout.session.completed': {\n          const sessionId = body.data.id;\n          const session = payments.get(sessionId);\n          \n          if (!session) {\n            throw new Error(`Session ${sessionId} not found`);\n          }\n          \n          // Update session\n          session.status = 'completed';\n          session.paymentStatus = 'paid';\n          \n          // Create subscription if mode is subscription\n          if (session.mode === 'subscription' && session.priceId) {\n            const subscriptionId = `mock_sub_${Date.now()}_${crypto.randomBytes(4).toString('hex')}`;\n            \n            // Get price details\n            let interval: 'day' | 'week' | 'month' | 'year' = 'month';\n            let intervalCount = 1;\n            \n            if (prices.has(session.priceId as string)) {\n              const price = prices.get(session.priceId as string)!;\n              if (price.recurring) {\n                interval = price.recurring.interval;\n                intervalCount = price.recurring.intervalCount;\n              }\n            }\n            \n            // Calculate period dates\n            const now = new Date();\n            const periodEnd = new Date(now);\n            \n            if (interval === 'day') {\n              periodEnd.setDate(periodEnd.getDate() + intervalCount);\n            } else if (interval === 'week') {\n              periodEnd.setDate(periodEnd.getDate() + (7 * intervalCount));\n            } else if (interval === 'month') {\n              periodEnd.setMonth(periodEnd.getMonth() + intervalCount);\n            } else if (interval === 'year') {\n              periodEnd.setFullYear(periodEnd.getFullYear() + intervalCount);\n            }\n            \n            // Create subscription\n            const subscription: MockSubscription = {\n              id: subscriptionId,\n              customerId: session.customerId as string,\n              status: 'active',\n              currentPeriodStart: now.toISOString(),\n              currentPeriodEnd: periodEnd.toISOString(),\n              cancelAtPeriodEnd: false,\n              canceledAt: null,\n              metadata: session.metadata,\n              createdAt: now.toISOString(),\n              items: [\n                {\n                  id: `mock_si_${Date.now()}_${crypto.randomBytes(4).toString('hex')}`,\n                  priceId: session.priceId as string,\n                  quantity: 1\n                }\n              ]\n            };\n            if (session.priceId) {\n              subscription.priceId = session.priceId;\n            }\n            \n            // Store subscription\n            subscriptions.set(subscriptionId, subscription);\n            \n            // Update session with subscription ID\n            session.subscriptionId = subscriptionId;\n            \n            _log('Mock subscription created from checkout:', subscriptionId);\n          }\n          \n          result = {\n            event: 'checkout.completed',\n            customerId: session.customerId,\n            customerEmail: session.customerEmail,\n            sessionId: session.id,\n            subscriptionId: session.subscriptionId,\n            amount: session.amount,\n            currency: session.currency,\n            metadata: session.metadata,\n            mode: session.mode,\n            status: session.status,\n            paymentStatus: session.paymentStatus\n          };\n          \n          break;\n        }\n        \n        case 'invoice.paid': {\n          const subscriptionId = body.data.subscription;\n          const subscription = subscriptions.get(subscriptionId);\n          \n          if (!subscription) {\n            throw new Error(`Subscription ${subscriptionId} not found`);\n          }\n          \n          // Update subscription period\n          const currentPeriodStart = new Date(subscription.currentPeriodEnd as string);\n          const currentPeriodEnd = new Date(subscription.currentPeriodEnd as string);\n          \n          // Get price details\n          let interval: 'day' | 'week' | 'month' | 'year' = 'month';\n          let intervalCount = 1;\n          \n          if (subscription.priceId && prices.has(subscription.priceId as string)) {\n            const price = prices.get(subscription.priceId as string)!;\n            if (price.recurring) {\n              interval = price.recurring.interval;\n              intervalCount = price.recurring.intervalCount;\n            }\n          }\n          \n          // Calculate new period end\n          if (interval === 'day') {\n            currentPeriodEnd.setDate(currentPeriodEnd.getDate() + intervalCount);\n          } else if (interval === 'week') {\n            currentPeriodEnd.setDate(currentPeriodEnd.getDate() + (7 * intervalCount));\n          } else if (interval === 'month') {\n            currentPeriodEnd.setMonth(currentPeriodEnd.getMonth() + intervalCount);\n          } else if (interval === 'year') {\n            currentPeriodEnd.setFullYear(currentPeriodEnd.getFullYear() + intervalCount);\n          }\n          \n          // Update subscription\n          subscription.currentPeriodStart = currentPeriodStart.toISOString();\n          subscription.currentPeriodEnd = currentPeriodEnd.toISOString();\n          \n          result = {\n            event: 'invoice.paid',\n            customerId: subscription.customerId,\n            subscriptionId: subscription.id,\n            invoiceId: `mock_inv_${Date.now()}_${crypto.randomBytes(4).toString('hex')}`,\n            amount: body.data.amount_paid || 1000,\n            currency: body.data.currency || 'usd',\n            status: 'paid'\n          };\n          \n          break;\n        }\n        \n        case 'customer.subscription.updated': {\n          const subscriptionId = body.data.id;\n          const subscription = subscriptions.get(subscriptionId);\n          \n          if (!subscription) {\n            throw new Error(`Subscription ${subscriptionId} not found`);\n          }\n          \n          // Update subscription\n          if (body.data.status) {\n            subscription.status = body.data.status;\n          }\n          \n          if (body.data.cancel_at_period_end !== undefined) {\n            subscription.cancelAtPeriodEnd = body.data.cancel_at_period_end;\n          }\n          \n          result = {\n            event: 'subscription.updated',\n            customerId: subscription.customerId,\n            subscriptionId: subscription.id,\n            status: subscription.status,\n            cancelAtPeriodEnd: subscription.cancelAtPeriodEnd,\n            currentPeriodEnd: subscription.currentPeriodEnd\n          };\n          \n          break;\n        }\n        \n        case 'customer.subscription.deleted': {\n          const subscriptionId = body.data.id;\n          const subscription = subscriptions.get(subscriptionId);\n          \n          if (!subscription) {\n            throw new Error(`Subscription ${subscriptionId} not found`);\n          }\n          \n          // Update subscription\n          subscription.status = 'canceled';\n          subscription.canceledAt = new Date().toISOString();\n          \n          result = {\n            event: 'subscription.deleted',\n            customerId: subscription.customerId,\n            subscriptionId: subscription.id,\n            status: subscription.status,\n            canceledAt: subscription.canceledAt\n          };\n          \n          break;\n        }\n        \n        default: {\n          result = {\n            event: body.type,\n            data: body.data\n          };\n        }\n      }\n      \n      _log('Mock webhook processed:', result.event);\n      \n      // Return top-level event result to match tests\n      (result as Record<string, unknown>).provider = 'mock';\n      return result as unknown as WebhookResult;\n    } catch (error) {\n      _log('Error handling mock webhook:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Create a customer\n   * @param {Object} options - Customer options\n   * @param {string} options.email - Customer email\n   * @param {string} options.name - Customer name (optional)\n   * @param {Object} options.metadata - Additional metadata\n   * @returns {Promise<Object>} - Customer\n   */\n  async function createCustomer(options: Partial<Customer> & { email: string; name?: string; metadata?: Record<string, unknown> }): Promise<Customer> {\n    try {\n      _log('Creating mock customer:', options);\n      \n      // Simulate delay\n      await _delay(config.delay);\n      \n      // Simulate error\n      if (_shouldSimulateError()) {\n        throw new Error('Simulated error creating customer');\n      }\n      \n      // Validate required options\n      if (!options.email) {\n        throw new Error('Customer email is required');\n      }\n      \n      // Check if customer already exists\n      for (const [id, customer] of customers.entries()) {\n        if (customer.email === options.email) {\n          _log('Customer already exists:', id);\n          \n          return {\n            id: customer.id,\n            email: customer.email,\n            name: customer.name,\n            metadata: customer.metadata,\n            provider: 'mock',\n            providerData: {\n              customerId: customer.id\n            }\n          };\n        }\n      }\n      \n      // Create a unique customer ID\n      const customerId = `mock_cus_${Date.now()}_${crypto.randomBytes(4).toString('hex')}`;\n      \n      // Create customer\n      const customer: Customer & { createdAt: string } = {\n        id: customerId,\n        email: options.email,\n        name: options.name,\n        metadata: (options.metadata as Record<string, unknown>) || {},\n        createdAt: new Date().toISOString()\n      };\n      \n      // Store customer\n      customers.set(customerId, customer);\n      \n      _log('Mock customer created:', customerId);\n      \n      // Return a standardized response\n      return {\n        id: customer.id,\n        email: customer.email,\n        name: customer.name,\n        metadata: customer.metadata,\n        provider: 'mock',\n        providerData: {\n          customerId: customer.id\n        }\n      };\n    } catch (error) {\n      _log('Error creating mock customer:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Get a customer\n   * @param {Object} options - Customer options\n   * @param {string} options.customerId - Customer ID\n   * @param {string} options.email - Customer email (optional)\n   * @returns {Promise<Object>} - Customer\n   */\n  async function getCustomer(options: { customerId?: string; email?: string }): Promise<Customer | null> {\n    try {\n      _log('Getting mock customer:', options);\n      \n      // Simulate delay\n      await _delay(config.delay);\n      \n      // Simulate error\n      if (_shouldSimulateError()) {\n        throw new Error('Simulated error getting customer');\n      }\n      \n      // Validate required options\n      if (!options.customerId && !options.email) {\n        throw new Error('Either customer ID or email is required');\n      }\n      \n      let customer: Customer | undefined;\n      \n      if (options.customerId) {\n        // Get customer by ID\n        customer = customers.get(options.customerId);\n      } else {\n        // Get customer by email\n        for (const cust of customers.values()) {\n          if (cust.email === options.email) {\n            customer = cust;\n            break;\n          }\n        }\n      }\n      \n      if (!customer) {\n        return null;\n      }\n      \n      _log('Mock customer retrieved:', customer.id);\n      \n      // Return a standardized response\n      return {\n        id: customer.id,\n        email: customer.email,\n        name: customer.name,\n        metadata: customer.metadata,\n        provider: 'mock',\n        providerData: {\n          customerId: customer.id\n        }\n      };\n    } catch (error) {\n      _log('Error getting mock customer:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Create a product\n   * @param {Object} options - Product options\n   * @param {string} options.name - Product name\n   * @param {string} options.description - Product description (optional)\n   * @param {Object} options.metadata - Additional metadata\n   * @returns {Promise<Object>} - Product\n   */\n  async function createProduct(options: { name: string; description?: string; metadata?: Record<string, unknown> }): Promise<Product> {\n    try {\n      _log('Creating mock product:', options);\n      \n      // Simulate delay\n      await _delay(config.delay);\n      \n      // Simulate error\n      if (_shouldSimulateError()) {\n        throw new Error('Simulated error creating product');\n      }\n      \n      // Validate required options\n      if (!options.name) {\n        throw new Error('Product name is required');\n      }\n      \n      // Create a unique product ID\n      const productId = `mock_prod_${Date.now()}_${crypto.randomBytes(4).toString('hex')}`;\n      \n      // Create product\n      const product: MockProduct = {\n        id: productId,\n        name: options.name,\n        description: options.description,\n        metadata: options.metadata || {},\n        createdAt: new Date().toISOString()\n      };\n      \n      // Store product\n      products.set(productId, product);\n      \n      _log('Mock product created:', productId);\n      \n      // Return a standardized response\n      return {\n        id: product.id,\n        name: product.name,\n        description: product.description,\n        metadata: product.metadata,\n        provider: 'mock',\n        providerData: {\n          productId: product.id\n        }\n      };\n    } catch (error) {\n      _log('Error creating mock product:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Create a price\n   * @param {Object} options - Price options\n   * @param {string} options.productId - Product ID\n   * @param {string} options.currency - Currency code (default: USD)\n   * @param {number} options.unitAmount - Amount in smallest currency unit (e.g., cents)\n   * @param {string} options.interval - Billing interval (day, week, month, year)\n   * @param {number} options.intervalCount - Number of intervals (default: 1)\n   * @param {Object} options.metadata - Additional metadata\n   * @returns {Promise<Object>} - Price\n   */\n  async function createPrice(options: { productId: string; currency: string; unitAmount: number; interval?: 'day' | 'week' | 'month' | 'year'; intervalCount?: number; metadata?: Record<string, unknown> }): Promise<Price> {\n    try {\n      _log('Creating mock price:', options);\n      \n      // Simulate delay\n      await _delay(config.delay);\n      \n      // Simulate error\n      if (_shouldSimulateError()) {\n        throw new Error('Simulated error creating price');\n      }\n      \n      // Validate required options\n      if (!options.productId) {\n        throw new Error('Product ID is required');\n      }\n      \n      if (!options.unitAmount) {\n        throw new Error('Unit amount is required');\n      }\n      \n      // Check if product exists\n      if (!products.has(options.productId)) {\n        throw new Error(`Product ${options.productId} not found`);\n      }\n      \n      // Create a unique price ID\n      const priceId = `mock_price_${Date.now()}_${crypto.randomBytes(4).toString('hex')}`;\n      \n      // Create price\n      const price: MockPrice = {\n        id: priceId,\n        productId: options.productId,\n        currency: (options.currency || 'usd').toLowerCase(),\n        unitAmount: options.unitAmount,\n        metadata: options.metadata || {},\n        createdAt: new Date().toISOString()\n      };\n      \n      // Add recurring parameters if interval is provided\n      if (options.interval) {\n        price.recurring = {\n          interval: options.interval,\n          intervalCount: options.intervalCount || 1\n        };\n      }\n      \n      // Store price\n      prices.set(priceId, price);\n      \n      // Update product with default price if not set\n      const product = products.get(options.productId)!;\n      if (!product.default_price) {\n        product.default_price = priceId;\n      }\n      \n      _log('Mock price created:', priceId);\n      \n      // Return a standardized response\n      return {\n        id: price.id,\n        productId: price.productId,\n        currency: price.currency,\n        unitAmount: price.unitAmount,\n        recurring: price.recurring,\n        metadata: price.metadata,\n        provider: 'mock',\n        providerData: {\n          priceId: price.id\n        }\n      };\n    } catch (error) {\n      _log('Error creating mock price:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Record usage for a customer and metric\n   */\n  async function recordUsage(options: UsageRecordOptions): Promise<UsageRecordResult> {\n    if (!options.customerId) throw new Error('customerId is required');\n    if (!options.metricKey) throw new Error('metricKey is required');\n    if (typeof options.quantity !== 'number') throw new Error('quantity is required');\n    const key = usageKey(options.customerId, options.metricKey);\n    const event: UsageEvent = {\n      id: `mock_usage_${Date.now()}_${crypto.randomBytes(3).toString('hex')}`,\n      customerId: options.customerId,\n      metricKey: options.metricKey,\n      quantity: options.quantity,\n      timestamp: options.timestamp || new Date().toISOString(),\n      metadata: options.metadata || {}\n    };\n    const { inserted } = await usageStorage.addEvent(key, event, options.idempotencyKey);\n    _log('Mock usage recorded:', { event, inserted, idempotencyKey: options.idempotencyKey });\n    return { id: event.id, success: true, provider: 'mock', providerData: { duplicate: !inserted } };\n  }\n\n  /**\n   * List usage events\n   */\n  async function getUsage(options: UsageQueryOptions): Promise<UsageEvent[]> {\n    const key = usageKey(options.customerId, options.metricKey);\n    const arr = await usageStorage.getEvents(key);\n    return arr.filter(e => inRange(e.timestamp, options.start, options.end));\n  }\n\n  /**\n   * Aggregate usage totals\n   */\n  async function getUsageAggregate(options: UsageAggregateOptions): Promise<UsageAggregate> {\n    const events = await getUsage(options);\n    const aggregation = options.aggregation || 'sum';\n    let total = 0;\n    if (aggregation === 'sum') {\n      total = events.reduce((acc, e) => acc + e.quantity, 0);\n    } else if (aggregation === 'count') {\n      total = events.length;\n    } else if (aggregation === 'max') {\n      total = events.reduce((acc, e) => Math.max(acc, e.quantity), 0);\n    } else {\n      total = events.length;\n    }\n    return { total };\n  }\n\n  /**\n   * Set a usage policy (limit per window)\n   */\n  async function setUsagePolicy(options: UsagePolicyOptions): Promise<UsagePolicy> {\n    const id = `${options.customerId}:${options.metricKey}`;\n    const policy: UsagePolicy = { id, ...options };\n    await usageStorage.setPolicy(id, policy);\n    return policy;\n  }\n\n  /**\n   * Check current usage against policy\n   */\n  async function checkUsageLimit(options: UsageLimitCheckOptions): Promise<UsageLimitResult> {\n    const id = `${options.customerId}:${options.metricKey}`;\n    const policy = await usageStorage.getPolicy(id);\n    if (!policy) {\n      return { allowed: true, remaining: Number.MAX_SAFE_INTEGER, usage: 0, policy: null };\n    }\n    const now = new Date();\n    let start: string | undefined;\n    if (policy.window === 'day') {\n      start = new Date(now.getFullYear(), now.getMonth(), now.getDate()).toISOString();\n    } else if (policy.window === 'month') {\n      start = new Date(now.getFullYear(), now.getMonth(), 1).toISOString();\n    } else {\n      start = new Date(now.getFullYear(), now.getMonth(), now.getDate(), now.getHours()).toISOString();\n    }\n    const usage = (await getUsageAggregate({ customerId: options.customerId, metricKey: options.metricKey, start, aggregation: 'sum' })).total;\n    const remaining = Math.max(0, policy.limit - usage);\n    return { allowed: remaining > 0, remaining, usage, policy };\n  }\n\n  /**\n   * Simulate a delay\n   * @param {number} ms - Delay in milliseconds\n   * @returns {Promise<void>} - Promise that resolves after the delay\n   * @private\n   */\n  function _delay(ms: number): Promise<void> {\n    return new Promise<void>(resolve => setTimeout(resolve, ms));\n  }\n  \n  /**\n   * Determine whether to simulate an error\n   * @returns {boolean} - Whether to simulate an error\n   * @private\n   */\n  function _shouldSimulateError(): boolean {\n    return config.simulateErrors && Math.random() < config.errorRate;\n  }\n  \n  /**\n   * Log debug messages\n   * @param {...any} args - Arguments to log\n   * @private\n   */\n  function _log(...args: unknown[]): void {\n    if (config.debug) {\n      console.log('[MockProvider]', ...args);\n    }\n  }\n  \n  // Return the provider\n  return {\n    createCheckoutSession,\n    createSubscription,\n    getSubscription,\n    cancelSubscription,\n    handleWebhook,\n    createCustomer,\n    getCustomer,\n    createProduct,\n    createPrice,\n    // Usage metering\n    recordUsage,\n    getUsage,\n    getUsageAggregate,\n    setUsagePolicy,\n    checkUsageLimit\n  };\n}\n\nexport default createMockProvider;"]}